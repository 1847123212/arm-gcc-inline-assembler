<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>arm-gcc-inline-assembler.md</title><link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text/css'><style type='text/css'>html, body {overflow-x: initial !important;}html { font-size: 14px; }
body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; font-size: 1rem; line-height: 1.42857; color: rgb(51, 51, 51); overflow-x: hidden; background-color: rgb(255, 255, 255); }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: rgb(181, 214, 252); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; word-wrap: break-word; position: relative; padding-bottom: 70px; white-space: pre-wrap; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
@media screen and (max-width: 500px) { 
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
.typora-export #write { margin: 0px auto; }
#write > p:first-child, #write > ul:first-child, #write > ol:first-child, #write > pre:first-child, #write > blockquote:first-child, #write > div:first-child, #write > table:first-child { margin-top: 30px; }
img { max-width: 100%; }
input, button, select, textarea { color: inherit; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
::before, ::after, * { box-sizing: border-box; }
#write p, #write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write div, #write pre { width: inherit; }
#write p, #write h1, #write h2, #write h3, #write h4, #write h5, #write h6 { position: relative; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
p { -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; -webkit-margin-start: 0px; -webkit-margin-end: 0px; }
.mathjax-block { margin-top: 0px; margin-bottom: 0px; -webkit-margin-before: 0rem; -webkit-margin-after: 0rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: bold; font-style: italic; }
a { cursor: pointer; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; margin: 4px 0px 0px; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 80px; }
.CodeMirror-gutters { border-right-width: 0px; background-color: inherit; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
pre { white-space: pre-wrap; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; position: relative !important; background: inherit; }
.md-fences .CodeMirror.CodeMirror-wrap { top: -1.6em; margin-bottom: -1.6em; }
.md-fences.mock-cm { white-space: pre-wrap; }
.show-fences-line-number .md-fences { padding-left: 0px; }
.show-fences-line-number .md-fences.mock-cm { padding-left: 40px; }
.footnotes { color: rgb(136, 136, 136); font-size: 0.9rem; padding-top: 1em; padding-bottom: 1em; }
.footnotes + .footnotes { margin-top: -1em; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; text-decoration: none; color: rgb(51, 51, 51); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; font-size: 1rem; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: normal; text-align: left; box-sizing: content-box; direction: ltr; background: transparent; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li p, li .mathjax-block { margin: 0.5rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; }
@media print { 
  html, body { height: 100%; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  h1, h2, h3, h4, h5, h6 { break-after: avoid-page; orphans: 2; }
  p { orphans: 4; }
  html.blink-to-pdf { font-size: 13px; }
  .typora-export #write { padding-left: 1cm; padding-right: 1cm; }
  .typora-export #write::after { height: 0px; }
  @page { margin: 20mm 0mm; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 2.86rem; white-space: pre-wrap; display: block; background: rgb(204, 204, 204); }
p > .md-image:only-child { display: inline-block; width: 100%; text-align: center; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.mathjax-block { white-space: pre; overflow: hidden; width: 100%; }
p + .mathjax-block { margin-top: -1.143rem; }
.mathjax-block:not(:empty)::after { display: none; }
[contenteditable="true"]:active, [contenteditable="true"]:focus { outline: none; box-shadow: none; }
.task-list { list-style-type: none; }
.task-list-item { position: relative; padding-left: 1em; }
.task-list-item input { position: absolute; top: 0px; left: 0px; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc::after, .md-toc-content::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: bold; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) { 
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { color: inherit; font-size: inherit; font-style: inherit; font-weight: inherit; text-decoration: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
.md-tag { opacity: 0.5; }
code { text-align: left; }
h1 .md-tag, h2 .md-tag, h3 .md-tag, h4 .md-tag, h5 .md-tag, h6 .md-tag { font-weight: initial; opacity: 0.35; }
a.md-header-anchor.md-print-anchor { border: none !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: none !important; text-decoration: initial !important; text-shadow: initial !important; background: transparent !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.mathjax-block .MathJax_SVG_Display { text-align: center; margin: 1em 0em; position: relative; text-indent: 0px; max-width: none; max-height: none; min-width: 0px; min-height: 0px; width: 100%; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: monospace; }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: normal; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none; }


@font-face { font-family: "Open Sans"; font-style: normal; font-weight: normal; src: local("Open Sans Regular"), url("./github/400.woff") format("woff"); }
@font-face { font-family: "Open Sans"; font-style: italic; font-weight: normal; src: local("Open Sans Italic"), url("./github/400i.woff") format("woff"); }
@font-face { font-family: "Open Sans"; font-style: normal; font-weight: bold; src: local("Open Sans Bold"), url("./github/700.woff") format("woff"); }
@font-face { font-family: "Open Sans"; font-style: italic; font-weight: bold; src: local("Open Sans Bold Italic"), url("./github/700i.woff") format("woff"); }
html { font-size: 16px; }
body { font-family: "Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif; color: rgb(51, 51, 51); line-height: 1.6; }
#write { max-width: 860px; margin: 0px auto; padding: 20px 30px 100px; }
#write > ul:first-child, #write > ol:first-child { margin-top: 30px; }
body > :first-child { margin-top: 0px !important; }
body > :last-child { margin-bottom: 0px !important; }
a { color: rgb(65, 131, 196); }
h1, h2, h3, h4, h5, h6 { position: relative; margin-top: 1rem; margin-bottom: 1rem; font-weight: bold; line-height: 1.4; cursor: text; }
h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor { text-decoration: none; }
h1 tt, h1 code { font-size: inherit; }
h2 tt, h2 code { font-size: inherit; }
h3 tt, h3 code { font-size: inherit; }
h4 tt, h4 code { font-size: inherit; }
h5 tt, h5 code { font-size: inherit; }
h6 tt, h6 code { font-size: inherit; }
h1 { padding-bottom: 0.3em; font-size: 2.25em; line-height: 1.2; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(238, 238, 238); }
h2 { padding-bottom: 0.3em; font-size: 1.75em; line-height: 1.225; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(238, 238, 238); }
h3 { font-size: 1.5em; line-height: 1.43; }
h4 { font-size: 1.25em; }
h5 { font-size: 1em; }
h6 { font-size: 1em; color: rgb(119, 119, 119); }
p, blockquote, ul, ol, dl, table { margin: 0.8em 0px; }
li > ol, li > ul { margin: 0px; }
hr { height: 4px; padding: 0px; margin: 16px 0px; border-width: 0px 0px 1px; border-style: none none solid; overflow: hidden; box-sizing: content-box; border-bottom-color: rgb(221, 221, 221); background-color: rgb(231, 231, 231); }
body > h2:first-child { margin-top: 0px; padding-top: 0px; }
body > h1:first-child { margin-top: 0px; padding-top: 0px; }
body > h1:first-child + h2 { margin-top: 0px; padding-top: 0px; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child { margin-top: 0px; padding-top: 0px; }
a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 { margin-top: 0px; padding-top: 0px; }
h1 p, h2 p, h3 p, h4 p, h5 p, h6 p { margin-top: 0px; }
li p.first { display: inline-block; }
ul, ol { padding-left: 30px; }
ul:first-child, ol:first-child { margin-top: 0px; }
ul:last-child, ol:last-child { margin-bottom: 0px; }
blockquote { border-left-width: 4px; border-left-style: solid; border-left-color: rgb(221, 221, 221); padding: 0px 15px; color: rgb(119, 119, 119); }
blockquote blockquote { padding-right: 0px; }
table { padding: 0px; }
table tr { border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); margin: 0px; padding: 0px; background-color: white; }
table tr:nth-child(2n) { background-color: rgb(248, 248, 248); }
table tr th { font-weight: bold; border: 1px solid rgb(204, 204, 204); text-align: left; margin: 0px; padding: 6px 13px; }
table tr td { border: 1px solid rgb(204, 204, 204); text-align: left; margin: 0px; padding: 6px 13px; }
table tr th:first-child, table tr td:first-child { margin-top: 0px; }
table tr th:last-child, table tr td:last-child { margin-bottom: 0px; }
.CodeMirror-gutters { border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); }
.md-fences, code, tt { border: 1px solid rgb(221, 221, 221); border-radius: 3px; font-family: Consolas, "Liberation Mono", Courier, monospace; padding: 2px 4px 0px; font-size: 0.9em; background-color: rgb(248, 248, 248); }
.md-fences { margin-bottom: 15px; margin-top: 15px; padding: 8px 1em 6px; }
.task-list { padding-left: 0px; }
.task-list-item { padding-left: 32px; }
.task-list-item input { top: 3px; left: 8px; }
@media screen and (min-width: 914px) { 
}
@media print { 
  html { font-size: 13px; }
  table, pre { break-inside: avoid; }
  pre { word-wrap: break-word; }
}
.md-fences { background-color: rgb(248, 248, 248); }
#write pre.md-meta-block { padding: 1rem; font-size: 85%; line-height: 1.45; border: 0px; border-radius: 3px; color: rgb(119, 119, 119); margin-top: 0px !important; background-color: rgb(247, 247, 247); }
.mathjax-block > .code-tooltip { bottom: 0.375rem; }
#write > h3.md-focus::before { left: -1.5625rem; top: 0.375rem; }
#write > h4.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
#write > h5.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
#write > h6.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
.md-image > .md-meta { border: 1px solid rgb(221, 221, 221); border-radius: 3px; font-family: Consolas, "Liberation Mono", Courier, monospace; padding: 2px 4px 0px; font-size: 0.9em; color: inherit; background-color: rgb(248, 248, 248); }
.md-tag { color: inherit; }
.md-toc { margin-top: 20px; padding-bottom: 20px; }
#typora-quick-open { border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); }
#typora-quick-open-item { border-color: rgb(254, 254, 254) rgb(229, 229, 229) rgb(229, 229, 229) rgb(238, 238, 238); border-style: solid; border-width: 1px; background-color: rgb(250, 250, 250); }
.on-focus-mode blockquote { border-left-color: rgba(85, 85, 85, 0.117647); }






</style>
</head>
<body class='typora-export ' >
<div  id='write'  class = 'is-node'><p><center></p><p><font color=red size=7><br><br>ARM GCC 内联汇编参考手册</font></p><p><font color=black size=5></p><p>ARM GCC Inline Assembler Cookbook（最新版）</p><p><br></p><p><br></p><p>Tidy Jiang 译.</p><p>2016 年 8 月.</p><p></font></p><p></p><p></center></p><p></p><p><div style="page-break-after: always;"></div></p><h1><a name='header-c32' class='md-header-anchor '></a>目录</h1><div class='md-toc' mdtype='toc'><p class="md-toc-content"><span class="md-toc-item md-toc-h1" data-ref="c32"><a class="md-toc-inner" href="#header-c32">目录</a></span><span class="md-toc-item md-toc-h1" data-ref="c36"><a class="md-toc-inner" href="#header-c36">翻译说明</a></span><span class="md-toc-item md-toc-h1" data-ref="c86"><a class="md-toc-inner" href="#header-c86">关于本文档</a></span><span class="md-toc-item md-toc-h1" data-ref="c92"><a class="md-toc-inner" href="#header-c92">GCC asm 申明</a></span><span class="md-toc-item md-toc-h1" data-ref="c153"><a class="md-toc-inner" href="#header-c153">C 代码优化</a></span><span class="md-toc-item md-toc-h1" data-ref="c195"><a class="md-toc-inner" href="#header-c195">其它要点</a></span><span class="md-toc-item md-toc-h2" data-ref="c196"><a class="md-toc-inner" href="#header-c196">使用内联汇编作为预处理宏</a></span><span class="md-toc-item md-toc-h2" data-ref="c200"><a class="md-toc-inner" href="#header-c200">C 桩函数</a></span><span class="md-toc-item md-toc-h2" data-ref="c204"><a class="md-toc-inner" href="#header-c204">替换 C 变量的符号名</a></span><span class="md-toc-item md-toc-h2" data-ref="c210"><a class="md-toc-inner" href="#header-c210">替换 C 变量的符号名</a></span><span class="md-toc-item md-toc-h2" data-ref="c216"><a class="md-toc-inner" href="#header-c216">强制使用指定的寄存器</a></span><span class="md-toc-item md-toc-h2" data-ref="c225"><a class="md-toc-inner" href="#header-c225">临时使用寄存器</a></span><span class="md-toc-item md-toc-h2" data-ref="c231"><a class="md-toc-inner" href="#header-c231">使用常量</a></span><span class="md-toc-item md-toc-h2" data-ref="c270"><a class="md-toc-inner" href="#header-c270">寄存器的用途</a></span><span class="md-toc-item md-toc-h1" data-ref="c342"><a class="md-toc-inner" href="#header-c342">常见陷阱</a></span><span class="md-toc-item md-toc-h2" data-ref="c343"><a class="md-toc-inner" href="#header-c343">指令顺序</a></span><span class="md-toc-item md-toc-h2" data-ref="c348"><a class="md-toc-inner" href="#header-c348">定义变量作为指定的寄存器</a></span><span class="md-toc-item md-toc-h2" data-ref="c363"><a class="md-toc-inner" href="#header-c363">在 thumb 状态执行</a></span><span class="md-toc-item md-toc-h2" data-ref="c366"><a class="md-toc-inner" href="#header-c366">汇编代码尺寸</a></span><span class="md-toc-item md-toc-h2" data-ref="c371"><a class="md-toc-inner" href="#header-c371">标签</a></span><span class="md-toc-item md-toc-h2" data-ref="c377"><a class="md-toc-inner" href="#header-c377">预处理宏</a></span><span class="md-toc-item md-toc-h1" data-ref="c382"><a class="md-toc-inner" href="#header-c382">外部链接</a></span><span class="md-toc-item md-toc-h1" data-ref="c387"><a class="md-toc-inner" href="#header-c387">版权</a></span><span class="md-toc-item md-toc-h1" data-ref="c389"><a class="md-toc-inner" href="#header-c389">文档历史</a></span></p></div><p><div style="page-break-after: always;"></div></p><h1><a name='header-c36' class='md-header-anchor '></a>翻译说明</h1><ul><li><p>原文链接：<a href='http://www.ethernut.de/en/documents/arm-inline-asm.html'>http://www.ethernut.de/en/documents/arm-inline-asm.html</a></p></li><li><p>本文档已有中文译文，翻译于2009年：<a href='http://blog.chinaunix.net/uid-20706279-id-1888741.html'>http://blog.chinaunix.net/uid-20706279-id-1888741.html</a></p></li><li><p>本文档英文原版已有多次更新，更改、新增的内容较多，详细修改历史请参考文档末尾 <em>文档历史</em> 一节</p></li><li><p>本文主体容是按照英文原文翻译的，只有在遇到极个别不理解的地方才参考了中文译文</p></li><li><p>在翻译本文时，本人尽量做到先理解，再翻译，以便更准确地将原文的意思呈现出来</p></li><li><p>如有<strong>任何</strong>问题，请前往如下地址参与评论、讨论：</p><ul><li>CSDN 博客：<a href='http://blog.csdn.net/tidyjiang/article/details/52138598'>http://blog.csdn.net/tidyjiang/article/details/52138598</a></li><li>个人博客：<a href='http://iot-fans.xyz/2016/08/05/zephyr/other-inline-assembler/'>http://iot-fans.xyz/2016/08/05/zephyr/other-inline-assembler/</a></li><li>个人博客：<a href='http://iot-fans.xyz/release/zephyr/arm-gcc-inline-assembler.html'>http://iot-fans.xyz/release/zephyr/arm-gcc-inline-assembler.html</a></li><li>GitHub：<a href='https://github.com/tidyjiang8/arm-gcc-inline-assembler'>https://github.com/tidyjiang8/arm-gcc-inline-assembler</a></li></ul></li><li><p>离线收藏、阅读请前往如下地址下载：</p><ul><li>个人博客：<a href='http://iot-fans.xyz/release/zephyr/arm-gcc-inline-assembler.pdf'>http://iot-fans.xyz/release/zephyr/arm-gcc-inline-assembler.pdf</a></li><li>GitHub: <a href='https://github.com/tidyjiang8/arm-gcc-inline-assembler'>https://github.com/tidyjiang8/arm-gcc-inline-assembler</a></li></ul></li><li><p>字数统计：6403 字</p></li></ul><p><div style="page-break-after: always;"></div></p><p></p><h1><a name='header-c86' class='md-header-anchor '></a>关于本文档</h1><p>GNU C 编译器为 ARM 精简指令系统处理器提供了在 C 代码中内嵌汇编的功能。这种非常酷的特性提供了一些 C 代码没有的功能，比如手工优化软件关键代码、使用相关的处理器指令。</p><p>本文假设你已经熟悉 ARM 汇编程序，因为本文档不是 ARM 汇编教程，也不是 C 语言教程。</p><p>本文中所有的例程只使用 GCC v4 测试过，但是它们多数都应该能在早期版本上工作。</p><h1><a name='header-c92' class='md-header-anchor '></a>GCC asm 申明</h1><p>以一个简单的例程开始。下面的汇编语句可以像其它任何 C 语句一样出现在你的代码中。</p><pre class='md-fences mock-cm' style='display:block;position:relative'>/* example 1: NOP */
asm(&quot;mov r0,r0&quot;);</pre><p>它将寄存器 r0 中的内容赋值给 r0。换句话说，它什么也没做。这种语句叫做 NOP（无操作）语句，通常用于实现一个极短的延时功能。</p><p>先等等！在将这个例程添加到你的 C 代码之前，请选继续阅读并学习本文后续部分，因为这段代码可能并不像我们所期望那样工作。</p><p>在内嵌汇编中使用汇编指令的方法与在纯汇编程序中使用汇编指令的方法一样。可以在一条 asm 语句中写多个汇编指令。但是为了增加程序的可读性，最好将每一条汇编指令单独放一行。</p><pre class='md-fences mock-cm' style='display:block;position:relative'>/* example 2: */
asm(
&quot;mov     r0, r0\n\t&quot;
&quot;mov     r0, r0\n\t&quot;
&quot;mov     r0, r0\n\t&quot;
&quot;mov     r0, r0&quot;
);</pre><p>换行符和制表符的使用可以使得指令列表看起来变得美观。你第一次看时可能觉得有点怪异，但是当 C 编译器编译 C 语句的时候，它就是按照上面（换行和制表）的格式生成汇编代码的。到目前为止，内嵌汇编指令和你写的纯汇编程序中的代码没什么区别。但事实上，对比其它的 C 语句，asm 语句对常量、寄存器的处理是不一样的。通用的内嵌汇编模版是这样的：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>asm(
    code 
    : 输出操作数列表
    : 输入操作数列表
    : clobber列表
    );</pre><p>sam 语句的第二部分(输出操作数列表)和第三部分(输入操作数列表)是可选的，它们在汇编语言与 C 语言之间提供一个桥梁作用。第三个部分(clobbers 列表)也是可选的，我们将在随后介绍。</p><p>再看另一个例程，一个 C 整型变量，向右移一位，并将结果保持到另一个整型变量中。</p><pre class='md-fences mock-cm' style='display:block;position:relative'>/* example 3: Rotating bits example */
asm(
    &quot;mov %[result], %[value], ror #1&quot; 
    : [result] &quot;=r&quot; (y) 
    : [value] &quot;r&quot; (x)
    );</pre><p>一条 asm 语句被冒号分为四个部分：</p><ol><li><p>使用字符串字面值描述的汇编指令：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>&quot;mov %[result], %[value], ror #1&quot;</pre></li><li><p>可选输出操作数列表。每个条目由方括号内的符号名、约束字符串、圆括号内的 C 表达式三部分组成：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>[result] &quot;=r&quot; (y)</pre></li><li><p>可选的输入操作数列表。其语法与输出操作数列表的语法相同。再次声明，这是可选的，且在我们的例程中只使用了一个操作数。</p><pre class='md-fences mock-cm' style='display:block;position:relative'>[value] &quot;r&quot; (x)</pre></li><li><p>可选的 clobber 寄存器列表。该列表在本例程中被忽略。</p></li></ol><p>只包含汇编指令的 asm 汇编叫做基本内联汇编，包含有可选部分的 asm 汇编叫做扩展内联汇编。</p><p>就像上面的 NOP 例程一样，如果尾部部分不使用，可以省略。但是需要注意，如果某一部分未使用，但是它后面的部分被使用了，那么必须将该部分空出。下面的例程用于设置 ARM CPU 的当前程序状态寄存器(CPSR)，它使用了输入操作数，但没有使用输出操作数：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>asm(
	&quot;msr cpsr,%[ps]&quot; 
	: 
	: [ps]&quot;r&quot;(status)
	);</pre><p>即使不使用汇编代码，代码部分也要保留空字符串。在下面的例程中，创建了一个特殊的 clobber，以告诉编译器内存环境可能已改变。再次声明，我们在后面讨论代码优化的时候会解释 clobber 列表。</p><pre class='md-fences mock-cm' style='display:block;position:relative'>asm(&quot;&quot;:::&quot;memory&quot;);</pre><p>为了增加程序的可读性，你可以插入空白、增加新行甚至添加 C 语言注释：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>asm(&quot;mov    %[result], %[value], ror #1&quot;

           : [result]&quot;=r&quot; (y) /* Rotation result. */
           : [value]&quot;r&quot;   (x) /* Rotated value. */
           : /* No clobbers */
    );</pre><p>在代码部分，你可以通过百分号%和符号名来引用操作数。这将引用操作数列表中的同名实体。在移位例程中：</p><p><em>%[result]</em> 引用了输出操作数中的 C 变量 y；<em>%[value]</em> 引用了输入操作数中的 C 变量 x。</p><p>符号操作的名字使用了独立的命令空间，这意味着本语句的符号名与其它任何符号表不相关。简单一点就是说你不必关心使用的符号名在 C 代码中已经使用了。不过，在同一条 asm 语句中的不同符号的名字不能相同。</p><p>如果你看到过早期的 C 代码，循环移位的例子必须要这么写：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>asm(
	&quot;mov %0, %1, ror #1&quot; 
	: &quot;=r&quot; (result) 
	: &quot;r&quot; (value)
	);</pre><p>操作数的引用是通过百分号加数字实现的，其中 %0 引用第一个操作数，%1 引用第二个操作数，以此递推。最新的 GCC 发行版中依然支持该格式，但是该格式很容易让人犯错并使代码难以维护。试想一下，如果你写了大量的汇编指令，但是你想插入一个新的输出操作数，你必须手工修改操作数的引用编号。</p><h1><a name='header-c153' class='md-header-anchor '></a>C 代码优化</h1><p>使用汇编语言主要有两个原因：第一，C 语言对硬件底层的处理被受到限制，比如 C 语句不能直接修改处理器的程序状态寄存器；第二，写出高度优化的代码。毫无疑问，虽然 GNU C 优化器的工作做得很好，但是其处理结果依然与手工汇编代码有差距。</p><p>本节的主题是我们容易忽略的部分：当使用内联汇编语句添加汇编语言代码时， C 编译器的代码优化器会对这些代码进行优化处理。我们来检查一下循环移位例程可能产生的汇编代码：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>00309DE5    ldr   r3, [sp, #0]    @ x, x
E330A0E1    mov   r3, r3, ror #1  @ tmp, x
04308DE5    str   r3, [sp, #4]    @ tmp, y</pre><p>编译器选择寄存器 r3 做循环移位使用，它也完全可以选择为每个 C 变量分配寄存器。可能不会显式地加载值或存储结果。下面是由不同版本的编译器使用不同编译选项生成的代码：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>E420A0E1    mov r2, r4, ror #1    @ y, x</pre><p>编译器为每个操作数选择一个相应的寄存器，使用已经缓存到 r4 中的值，并将 r2 中的结果传递给后面的代码。这个过程你能理解不？</p><p>有时候会更糟糕。有时候编译器甚至完全抛弃你嵌入的汇编代码。C 编译器的这种行为，取决于代码优化器的策略或嵌入汇编处的上下文。例如，如果你在后面的 C 程序中不再使用内联汇编中的任何输出操作数，优化器很有可能会删除掉你的内联汇编语句。在最开始的 NOP 例程中就可能出现这样的情况，因为编译器认为这段代码没有意义，只会增加开销、降低程序的执行效率。</p><p>上面问题的解决方法是使用 volatile 关键字指示编译器不要优化这段代码。NOP 的例程修改后的代码如下：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>/* NOP example, revised */
asm volatile(&quot;mov r0, r0&quot;);</pre><p>下面还有更多的烦恼等着我们。一个设计精细的优化器可能重新排列代码。看下面的代码：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>i++;
if (j == 1)
    x += 3;
i++;</pre><p>对于上面的代码，优化器认为两个 i++ 语句将不会影响 if 条件语句的执行，而且如果 i 的值增加 2 将节省一条 ARM 汇编指令，因此编译器将重新组织代码：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>if (j == 1)
    x += 3;
i += 2;</pre><p>因此，我们无法保证编译后的代码与源代码中的语句的顺序相同。</p><p>这种行为可能会对我们的代码产生很大的副作用。下面一段代码的作用是计算 b 和 c 的乘积。其中，b 和/或 c 的值可能会被中的例程修改。因此，我们在访问变量前先禁止中断，并在完成计算后再重新使能中断。</p><pre class='md-fences mock-cm' style='display:block;position:relative'>asm volatile(&quot;mrs r12, cpsr\n\t&quot;
    &quot;orr r12, r12, #0xC0\n\t&quot;
    &quot;msr cpsr_c, r12\n\t&quot; ::: &quot;r12&quot;, &quot;cc&quot;);
c *= b; /* This may fail. */
asm volatile(&quot;mrs r12, cpsr\n&quot;
    &quot;bic r12, r12, #0xC0\n&quot;
    &quot;msr cpsr_c, r12&quot; ::: &quot;r12&quot;, &quot;cc&quot;);</pre><p>不幸的是，优化器可能会让乘积指令先执行，再执行两个内联汇编指令，或者相反。这会让我们的汇编代码毫无意义。</p><p>对于这个问题，我们可以借助于 clobber 列表。该例程中的 clobber 列表如下：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>&quot;r12&quot;, &quot;cc&quot;</pre><p>这条 colbber 列表将给编译器传达如下信息：我这段汇编代码修改了寄存器 r12 的值，并更新了程序状态寄存器的标志位。顺便说一下，直接指明使用的寄存器，将有可能阻止了最好的优化结果。一般情况下，你应该传递一个变量，让编译器自己选择寄存器。clobber 列表中的关键字，除了寄存器名和 cc(状态寄存器标志位)，还包括 memory。memory 关键字用来指示编译器，该汇编指令改变了内存中的值。这将强制编译器在执行汇编指令前将所有缓存的值保存起来，并在汇编指令执行完后再将这些值加载进去。此外，编译器还必须保留执行顺序，因为在执行完带有 memory 关键字的 asm 语句后，所有变量的内容都是无法预测的。</p><pre class='md-fences mock-cm' style='display:block;position:relative'>asm volatile(&quot;mrs r12, cpsr\n\t&quot;
    &quot;orr r12, r12, #0xC0\n\t&quot;
    &quot;msr cpsr_c, r12\n\t&quot; :: : &quot;r12&quot;, &quot;cc&quot;, &quot;memory&quot;);
c *= b; /* This is safe. */
asm volatile(&quot;mrs r12, cpsr\n&quot;
    &quot;bic r12, r12, #0xC0\n&quot;
    &quot;msr cpsr_c, r12&quot; ::: &quot;r12&quot;, &quot;cc&quot;, &quot;memory&quot;);</pre><p>使所有缓存值无效可能是次优化的。你也可以添加一个虚拟操作数来创建一个虚拟依赖：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>asm volatile(&quot;mrs r12, cpsr\n\t&quot;
    &quot;orr r12, r12, #0xC0\n\t&quot;
    &quot;msr cpsr_c, r12\n\t&quot; : &quot;=X&quot; (b) :: &quot;r12&quot;, &quot;cc&quot;);
c *= b; /* This is safe. */
asm volatile(&quot;mrs r12, cpsr\n&quot;
    &quot;bic r12, r12, #0xC0\n&quot;
    &quot;msr cpsr_c, r12&quot; :: &quot;X&quot; (c) : &quot;r12&quot;, &quot;cc&quot;);</pre><p>上述代码中，第一条汇编语句尝试去修改变量 b ，第二条汇编语句尝试使用变量 c 。这将保留三个语句的执行顺序，而不要使缓存的变量无效。</p><p>理解优化器对内嵌汇编的影响很重要。如果你读到这里还是云里雾里，最好是在看下个主题之前再把这段文章读几遍^_^。</p><h1><a name='header-c195' class='md-header-anchor '></a>其它要点</h1><h2><a name='header-c196' class='md-header-anchor '></a>使用内联汇编作为预处理宏</h2><p>对于经常需要重用的汇编代码，你可以将它们定义成宏放在头文件中。不过，如果这些头文件用在模块中，将导致编译器在严格 ANSI 模式下时产生警告信息。为了消除警告，需要将 asm 用 <strong>asm</strong>、volatile 用 <strong>volatile</strong> 替换掉。<strong>asm</strong> 和 <strong>volatile</strong> 相当于 asm 和 volatile 的别名。下面的宏可以将一个长整型值从小端转到大段或者相反。</p><pre class='md-fences mock-cm' style='display:block;position:relative'>#define BYTESWAP(val) \
    __asm__ __volatile__ ( \
        &quot;eor     r3, %1, %1, ror #16\n\t&quot; \
        &quot;bic     r3, r3, #0x00FF0000\n\t&quot; \
        &quot;mov     %0, %1, ror #8\n\t&quot; \
        &quot;eor     %0, %0, r3, lsr #8&quot; \
        : &quot;=r&quot; (val) \
        : &quot;0&quot;(val) \
        : &quot;r3&quot;, &quot;cc&quot; \
    );</pre><h2><a name='header-c200' class='md-header-anchor '></a>C 桩函数</h2><p>当宏被引用时，它将在每个引用处展开为相同的汇编代码，这在大型程序中是不可接受的。在这种情形下，你可以定义一个 C 桩(stub)函数。将上面的宏以 C 函数形式重新实现如下：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>unsigned long ByteSwap(unsigned long val)
{
asm volatile (
        &quot;eor     r3, %1, %1, ror #16\n\t&quot;
        &quot;bic     r3, r3, #0x00FF0000\n\t&quot;
        &quot;mov     %0, %1, ror #8\n\t&quot;
        &quot;eor     %0, %0, r3, lsr #8&quot;
        : &quot;=r&quot; (val)
        : &quot;0&quot;(val)
        : &quot;r3&quot;
);
return val;
}
</pre><h2><a name='header-c204' class='md-header-anchor '></a>替换 C 变量的符号名</h2><p>默认情况下，GCC 在 C 和汇编代码中的函数、变量使用相同的符号名。你可以使用一个特殊的格式— asm 语句 — 为汇编代码指定不同的名字：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>unsigned long value asm(&quot;clock&quot;) = 3686400;</pre><p>该语句指示编译器在生成汇编代码时使用 clock 作为符号名，而不要使用默认的 value。这只对全局变量有效，因为局部变量（又叫自动变量）在汇编代码中没有符号名。</p><h2><a name='header-c210' class='md-header-anchor '></a>替换 C 变量的符号名</h2><p>虽然编译器不允许在函数定义中使用 asm 关键字，但是你可以通过原型声明来改变函数的名字：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>extern long Calc(void) asm (&quot;CALCULATE&quot;);</pre><p>调用函数 <em>Clac()</em> 时将会调用到汇编指令中的函数 <em>CALCULATE</em>。</p><h2><a name='header-c216' class='md-header-anchor '></a>强制使用指定的寄存器</h2><p>局部变量可以存储在寄存器中。你可以使用内联汇编为局部变量指定一个寄存器。</p><pre class='md-fences mock-cm' style='display:block;position:relative'>void Count(void) {
register unsigned char counter asm(&quot;r3&quot;);

... some code...
asm volatile(&quot;eor r3, r3, r3&quot; : &quot;=l&quot; (counter));
... more code...
}</pre><blockquote><p>译注：eor 是异或指令，其原型是 EOR <dest&gt;, &lt;操作数1&gt;, &lt;操作数2&gt;。</p></blockquote><p>汇编指令 &quot;eor r3, r3, r3&quot; 将清除变量 counter 的值(清零)。需要注意，在大多数情况下使用该指令都不是一个好主意，原因有两点：该指令会与编译器的优化器产生冲突；GCC 不会为相关的寄存器保留完整的备份。如果编译器认为变量不会再被引用，那么对应的寄存器就会被重用(re-used)。编译器没有能力检查这些寄存器是否与其它预定义寄存器之间存在冲突。如果你用这种方式指定了太多的寄存器，编译器甚至可能在产生代码时就将寄存器耗尽。</p><h2><a name='header-c225' class='md-header-anchor '></a>临时使用寄存器</h2><p>如果你使用了寄存器，但是该寄存器没有出现在操作数中，那么你需要告诉编译器你使用了该寄存器。下面的例子将一个值调整为 4 的倍数，它使用 r3 作为 scratch 寄存器，并将其指定在 clobber 列表中，以告知编译器。此外，ands 指令修改了 CPU 的状态标识，因此也将 cc 添加到 clobber 列表中了。</p><pre class='md-fences mock-cm' style='display:block;position:relative'>asm volatile(
    &quot;ands    r3, %1, #3&quot;     &quot;\n\t&quot;
    &quot;eor     %0, %0, r3&quot; &quot;\n\t&quot;
    &quot;addne   %0, #4&quot;
    : &quot;=r&quot; (len)
    : &quot;0&quot; (len)
    : &quot;cc&quot;, &quot;r3&quot;
  );</pre><p>再次声明，直接将寄存器的用法写死（hard coding）总是一个坏习惯！更好的实现方法是使用 C 桩函数，并使用局部变量作为临时值。</p><h2><a name='header-c231' class='md-header-anchor '></a>使用常量</h2><p>你可以使用 mov 指令将一个立即数常量值加载到寄存器中。这个常量值通常将限定在 0~255 之间。</p><pre class='md-fences mock-cm' style='display:block;position:relative'>asm(&quot;mov r0, %[flag]&quot; : : [flag] &quot;I&quot; (0x80));</pre><p>但是当在给定范围内移位偶数个比特的时候，也可以使用一个更大的值。换言之，该值可以是<span class="MathJax_Preview"></span><span class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="-1" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.924ex" height="2.11ex" viewBox="0 -806.1 2550.8 908.7" role="img" focusable="false" style="vertical-align: -0.238ex;"><defs><path stroke-width="1" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path stroke-width="1" id="E1-MJMAIN-2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path><path stroke-width="1" id="E1-MJMAIN-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path stroke-width="1" id="E1-MJMATHI-78" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#E1-MJMATHI-6E" x="0" y="0"></use><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#E1-MJMAIN-2217" x="822" y="0"></use><g transform="translate(1545,0)"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#E1-MJMAIN-32" x="0" y="0"></use><use transform="scale(0.707)" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#E1-MJMATHI-78" x="707" y="583"></use></g></g></svg></span></span><script type="math/tex; mode=display" id="MathJax-Element-1">n * 2 ^x</script>。其中 n 是上面提到的 0~255，x 是 0~24 中的偶数。由于可以翻转，x 可以被设为 26、28 或 30，在这种情况下，比特 37~32 被翻转到比特 5~0。最后，当使用 mvn 指令代替 mov 指令时，需要使用这些值的二进制补码。</p><p>如果你需要跳转到一个由预处理宏定义的固定内存地址处，你可以使用下面的汇编代码：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>    ldr  r3, =JMPADDR
    bx   r3</pre><p>如果上述常量是一个合法地址（比如 0x20000000），聪明的汇编器就会将上面的代码转换为：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>    mov  r3, #0x20000000
    bx   r3</pre><p>如果不合法（比如 0x00F000F0），汇编器将会从文字池（literal pool）中加载其值。</p><pre class='md-fences mock-cm' style='display:block;position:relative'>    ldr  r3, .L1
    bx   r3
    ...
    .L1: .word 0x00F000F0</pre><p>内联汇编与上述汇编代码的的工作方式相同。但是你不需要使用 ldr 指令，你只需要提供一个常量作为寄存器的值：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>asm volatile(&quot;bx %0&quot; : : &quot;r&quot; (JMPADDR));</pre><p>根据常量的实际值，你可以使用 mov 或 ldr 指令的变体。例如，如果 JMPADDR 被定义为 0xFFFFFF00，那么相应的代码类似于：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>    mvn  r3, #0xFF
    bx   r3</pre><p>真实世界当然比这个更复杂，比如可能有这样的需求：我们需要将一个常量加载到一个特殊寄存器中。假设我们想要调用一个子程序，但是在调用完后返回到另一个地址。当嵌入式固件从 main 返回时，这样做会很有用。在这种情况下，我们需要将值加载到连接寄存器(lr)。汇编代码如下：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>    ldr  lr, =JMPADDR
    ldr  r3, main
    bx   r3</pre><p>想到如何用内联汇编实现这段代码吗？答案是：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>asm volatile(
    &quot;mov lr, %1\n\t&quot;
    &quot;bx %0\n\t&quot;
    : : &quot;r&quot; (main), &quot;I&quot; (JMPADDR));</pre><p>但是还有一个问题。我们这里使用的是 mov 指令。当 JMPADDR 的值合法时，代码将能像我们期待那样正常工作。当不合法时，需要使用 ldr 指令代替。但是不幸的是，内联汇编中没有这样的表达式</p><pre class='md-fences mock-cm' style='display:block;position:relative'>    ldr  lr, =JMPADDR</pre><p>相反，我们必须写成</p><pre class='md-fences mock-cm' style='display:block;position:relative'>asm volatile(
    &quot;mov lr, %1\n\t&quot;
    &quot;bx %0\n\t&quot;
    : : &quot;r&quot; (main), &quot;r&quot; (JMPADDR));</pre><p>与纯汇编代码相比，我们使用了一条额外的语句作为结尾——使用一个额外的寄存器。</p><pre class='md-fences mock-cm' style='display:block;position:relative'>    ldr     r3, .L1
    ldr     r2, .L2
    mov     lr, r2
    bx      r3</pre><blockquote><p>注：好晕，但是翻译得应该没问题。</p></blockquote><h2><a name='header-c270' class='md-header-anchor '></a>寄存器的用途</h2><p>比较好的学习方法是分析编译后的汇编清单，并学习 C 编译器生成的代码。下面的表格是编译器典型使用的 ARM 寄存器，知道这些将有助于理解代码。</p><table><thead><tr><th><strong>寄存器</strong></th><th><strong>别名</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td>r0</td><td>a1</td><td>第一个函数参数 <br>Scratch 寄存器</td></tr><tr><td>r1</td><td>a2</td><td>第二个函数参数 <br>Scratch 寄存器</td></tr><tr><td>r2</td><td>a3</td><td>第三个函数参数<br>Scratch 寄存器</td></tr><tr><td>r3</td><td>a4</td><td>第四个函数参数<br>Scratch 寄存器</td></tr><tr><td>r4</td><td>v1</td><td>寄存器变量</td></tr><tr><td>r5</td><td>v2</td><td>寄存器变量</td></tr><tr><td>r6</td><td>v3</td><td>寄存器变量</td></tr><tr><td>r7</td><td>v4</td><td>寄存器变量</td></tr><tr><td>r8</td><td>v5</td><td>寄存器变量</td></tr><tr><td>r9</td><td>v6 </br>rfp</td><td>寄存器变量<br>实际的帧指针</td></tr><tr><td>r10</td><td>sl</td><td>栈接线</td></tr><tr><td>r11</td><td>fp</td><td>参数指针</td></tr><tr><td>r12</td><td>ip</td><td>临时</td></tr><tr><td>r13</td><td>sp</td><td>栈指针</td></tr><tr><td>r14</td><td>lr</td><td>连接寄存器</td></tr><tr><td>r15</td><td>pc</td><td>程序计数</td></tr></tbody></table><h1><a name='header-c342' class='md-header-anchor '></a>常见陷阱</h1><h2><a name='header-c343' class='md-header-anchor '></a>指令顺序</h2><p>开发者总是自以为源代码中指定的指令顺序与最终的指令顺序一致。这种写法是错误的，并导致难以查找bug。实际上，优化器会像优化 C 语句那样优化汇编语句。如果有可能，指令的顺序可能会重排。</p><p>“优化 C 代码”一节对此进行了详细讨论并提供了解决方案。</p><h2><a name='header-c348' class='md-header-anchor '></a>定义变量作为指定的寄存器</h2><p>即使将一个变量强制赋值给了一个指定的寄存器，代码运行的结果也可能不是我们所期望的。考虑如下片段：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>int foo(int n1, int n2) {
  register int n3 asm(&quot;r7&quot;) = n2;
  asm(&quot;mov r7, #4&quot;);
  return n3;
}</pre><p>编译器被指示使用 r7 作为局部变量 n3，且使用参数 n2 进行初始化。接着在内联汇编语句中将 r7 设为 4，最后再返回。然后，这完全错了！一定要记住，编译器不知道内联汇编中发生了什么，但是优化器对 C 代码很聪明，将产生如下汇编代码：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>foo:
  mov r7, #4
  mov r0, r1
  bx  lr</pre><p>返回的结果不是 r7，而是 n2 的值。n2 会在我们的函数中传递给寄存器 r1。发生了什么？尽管最终的代码中包含了我们的内联汇编语句，C 代码优化器认为完全不需要使用 n3。它直接返回了参数 n2 。</p><p>仅仅将一个变量分配一个固定的寄存器不意味着 C 编译器将使用这个变量。我们仍然需要告诉编译器，在内联汇编的操作数中，有一个变量被修改了。对于给定了例程，我们需要在 asm 语句的输出操作数中做扩展：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>asm(&quot;mov %0, #4&quot; : &quot;=l&quot; (n3));</pre><p>现在，C 编译器知道 n3 被修改了，并将产生我们期望的结果：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>foo:
  push {r7, lr}
  mov  r7, #4
  mov  r0, r7
  pop  {r7, pc}</pre><h2><a name='header-c363' class='md-header-anchor '></a>在 thumb 状态执行</h2><p>需要注意，依赖于所给定的编译选项，编译器可能会切换到 thumb 状态。使用在 thumb 状态时无效的内联汇编指令将导致隐藏的编译错误。</p><h2><a name='header-c366' class='md-header-anchor '></a>汇编代码尺寸</h2><p>在大多数情况下，编译器能正确的判断汇编指令的尺寸，但是当有汇编宏的时候是例外。因此最好避免之。</p><p>你可能会感到困惑：是汇编语言宏，不是 C 预处理宏。使用后者更好。</p><h2><a name='header-c371' class='md-header-anchor '></a>标签</h2><p>在汇编指令中，你可以使用标签来达到跳转的目的。不过，你不能由一个汇编指令调整到另一个汇编指令。优化器只知道这些跳转将产生坏代码。</p><blockquote><p>What ? 没明白！</p></blockquote><h2><a name='header-c377' class='md-header-anchor '></a>预处理宏</h2><p>内联汇编指令不能包含预处理宏，因为对于预处理器而言，这些指令仅仅是字符常量。</p><p>如果你的汇编代码中必须引用宏中的值，请参考“使用常量”一节。</p><h1><a name='header-c382' class='md-header-anchor '></a>外部链接</h1><p>如果想要更深入地讨论内联汇编，请参考 gcc 用户手册。最新版的 gcc 用户手册位于：</p><p><a href='http://gcc.gnu.org/onlinedocs/'>http://gcc.gnu.org/onlinedocs/</a></p><h1><a name='header-c387' class='md-header-anchor '></a>版权</h1><pre class='md-fences mock-cm' style='display:block;position:relative'>Copyright (C) 2007-2013 by Harald Kipp.
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation.</pre><h1><a name='header-c389' class='md-header-anchor '></a>文档历史</h1><table><thead><tr><th>日期 (年月日)</th><th>改动</th><th>致谢</th></tr></thead><tbody><tr><td>2014/02/11</td><td>更正第一个常量例程，常量必须作为输入操作数</td><td>spider391Tang</td></tr><tr><td>2013/08/16</td><td>更正特殊寄存器语法的例程代码，在<em>陷阱</em>章节增加若干主题</td><td>Sven Köhler</td></tr><tr><td>2012/03/28</td><td>更正<em>陷阱</em>章节中常量传输的错误，并移动到<em>使用</em>章节</td><td>enh</td></tr><tr><td></td><td>添加预处理宏陷阱</td><td></td></tr><tr><td></td><td>添加本历史</td><td></td></tr></tbody></table></div>
</body>
</html>